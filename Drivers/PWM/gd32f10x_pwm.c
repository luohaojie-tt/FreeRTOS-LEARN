/**
  ******************************************************************************
  * @file    gd32f10x_pwm.c
  * @author  Auto-generated by Claude Code
  * @version V1.0.0
  * @date    24-August-2025
  * @brief   This file provides all the PWM firmware functions.
  ******************************************************************************
  * @attention
  *
  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  *
  * COPYRIGHT 2025 GIGADEVICE
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "gd32f10x_pwm.h"
#include "gd32f10x_rcc.h"

/** @addtogroup GD32F10x_StdPeriph_Driver
  * @{
  */

/** @defgroup PWM 
  * @brief PWM driver modules
  * @{
  */

/** @defgroup PWM_Private_TypesDefinitions
  * @{
  */

/**
  * @}
  */

/** @defgroup PWM_Private_Defines
  * @{
  */

/* ---------------------- PWM registers bit mask ------------------------ */
#define CTL0_CEN_SET          ((uint16_t)0x0001)
#define CTL0_CEN_RESET        ((uint16_t)0x03FE)
#define CCHP_OAEN_SET         ((uint16_t)0x4000)
#define CCHP_OAEN_RESET       ((uint16_t)0x7FFF)

/**
  * @}
  */

/** @defgroup PWM_Private_Macros
  * @{
  */

/**
  * @}
  */

/** @defgroup PWM_Private_Variables
  * @{
  */

/**
  * @}
  */

/** @defgroup PWM_Private_FunctionPrototypes
  * @{
  */

/**
  * @}
  */

/** @defgroup PWM_Private_Functions
  * @{
  */

/**
  * @brief  Deinitializes the TIMERx peripheral registers to their default reset values.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @retval None
  */
void PWM_DeInit(TIMER_TypeDef* TIMERx)
{
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
 
  if (TIMERx == TIMER0)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIMER0, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIMER0, DISABLE);
  } 
  else if (TIMERx == TIMER1)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIMER1, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIMER1, DISABLE);
  }
  else if (TIMERx == TIMER2)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIMER2, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIMER2, DISABLE);
  }
  else if (TIMERx == TIMER3)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIMER3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIMER3, DISABLE);
  } 
  else if (TIMERx == TIMER4)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIMER4, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIMER4, DISABLE);
  }
}

/**
  * @brief  Initializes the TIMERx peripheral according to the specified
  *         parameters in the PWM_InitStruct.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_InitStruct: pointer to a PWM_InitTypeDef structure
  *         that contains the configuration information for the specified TIMER peripheral.
  * @retval None
  */
void PWM_Init(TIMER_TypeDef* TIMERx, PWM_InitTypeDef* PWM_InitStruct)
{
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
  uint32_t tmpcnt = 0, tmpdivider = 0, tmpfreq = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx)); 
  assert_param(IS_PWM_CHANNEL(PWM_InitStruct->PWM_Channel));
  assert_param(IS_PWM_COUNTER_MODE(PWM_InitStruct->PWM_CounterMode));
  assert_param(IS_PWM_OC_MODE(PWM_InitStruct->PWM_OCMode));
  assert_param(IS_PWM_OC_POLARITY(PWM_InitStruct->PWM_OCPolarity));
  assert_param(IS_FUNCTIONAL_STATE(PWM_InitStruct->PWM_OutputState));
  assert_param(IS_FUNCTIONAL_STATE(PWM_InitStruct->PWM_OutputNState));
  assert_param(IS_PWM_OUTPUT_IDLE_STATE(PWM_InitStruct->PWM_OCIdleState));
  assert_param(IS_PWM_OUTPUTN_IDLE_STATE(PWM_InitStruct->PWM_OCNIdleState));
  assert_param(IS_PWM_FREQUENCY(PWM_InitStruct->PWM_Frequency));
  assert_param(IS_PWM_DUTYCYCLE(PWM_InitStruct->PWM_DutyCycle));
  
  /* Calculate the prescaler value */
  tmpdivider = SystemCoreClock / 1000000;  /* 1MHz */
  tmpfreq = 1000000 / PWM_InitStruct->PWM_Frequency;
  
  /* Set the Autoreload value */
  TIMERx->CAR = tmpfreq - 1;
  
  /* Set the Prescaler value */
  TIMERx->PSC = tmpdivider - 1;
  
  /* Set the Counter Mode */
  TIMERx->CTL0 &= (uint16_t)(~((uint16_t)(TIMER_CTL0_DIR | TIMER_CTL0_CAM)));
  TIMERx->CTL0 |= PWM_InitStruct->PWM_CounterMode;
  
  /* Set the clock division */
  TIMERx->CTL0 &= (uint16_t)(~((uint16_t)TIMER_CTL0_CKDIV));
  TIMERx->CTL0 |= (uint16_t)TIMER_CKD_DIV1;
  
  /* Select the Channel */
  switch (PWM_InitStruct->PWM_Channel)
  {
    case PWM_CHANNEL_0:
      /* Get the TIMERx CHCTLR1 register value */
      tmpccmrx = TIMERx->CHCTLR1;
      /* Reset the Output Compare Mode Bits */
      tmpccmrx &= (uint16_t)(~((uint16_t)TIMER_CHCTLR1_OC1M));
      tmpccmrx &= (uint16_t)(~((uint16_t)TIMER_CHCTLR1_CC1S));
      
      /* Select the Output Compare Mode */
      tmpccmrx |= PWM_InitStruct->PWM_OCMode;
      
      /* Reset the Output Polarity level */
      tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH0P));
      /* Set the Output Compare Polarity */
      tmpccer |= PWM_InitStruct->PWM_OCPolarity;
      
      /* Set the Output State */
      if(PWM_InitStruct->PWM_OutputState == ENABLE)
      {
        tmpccer |= (uint16_t)TIMER_CHCTL2_CH0EN;
      }
      else
      {
        tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH0EN));
      }
      
      /* Set the Output N State */
      if(PWM_InitStruct->PWM_OutputNState == ENABLE)
      {
        tmpccer |= (uint16_t)TIMER_CHCTL2_CH0NEN;
      }
      else
      {
        tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH0NEN));
      }
      
      /* Set the Capture Compare Register value */
      tmpcnt = (uint32_t)((tmpfreq * PWM_InitStruct->PWM_DutyCycle) / 100);
      TIMERx->CH0CV = (uint32_t)tmpcnt;
      
      /* Write to TIMERx CHCTLR1 */
      TIMERx->CHCTLR1 = tmpccmrx;
      
      /* Set the Capture Compare Register Preload Bit */
      TIMERx->CHCTLR1 |= (uint16_t)TIMER_CHCTLR1_OC1PE;
      
      /* Write to TIMERx CHCTL2 */
      TIMERx->CHCTL2 = tmpccer;
      
      /* Write to TIMERx CCHP */
      TIMERx->CCHP &= (uint16_t)(~((uint16_t)TIMER_CCHP_OAEN));
      TIMERx->CCHP |= ((uint16_t)PWM_InitStruct->PWM_OCIdleState | (uint16_t)PWM_InitStruct->PWM_OCNIdleState);
      break;
      
    case PWM_CHANNEL_1:
      /* Get the TIMERx CHCTLR1 register value */
      tmpccmrx = TIMERx->CHCTLR1;
      /* Reset the Output Compare Mode Bits */
      tmpccmrx &= (uint16_t)(~((uint16_t)TIMER_CHCTLR1_OC2M));
      tmpccmrx &= (uint16_t)(~((uint16_t)TIMER_CHCTLR1_CC2S));
      
      /* Select the Output Compare Mode */
      tmpccmrx |= (uint16_t)(PWM_InitStruct->PWM_OCMode << 8);
      
      /* Reset the Output Polarity level */
      tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH1P));
      /* Set the Output Compare Polarity */
      tmpccer |= (uint16_t)(PWM_InitStruct->PWM_OCPolarity << 4);
      
      /* Set the Output State */
      if(PWM_InitStruct->PWM_OutputState == ENABLE)
      {
        tmpccer |= (uint16_t)TIMER_CHCTL2_CH1EN;
      }
      else
      {
        tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH1EN));
      }
      
      /* Set the Output N State */
      if(PWM_InitStruct->PWM_OutputNState == ENABLE)
      {
        tmpccer |= (uint16_t)TIMER_CHCTL2_CH1NEN;
      }
      else
      {
        tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH1NEN));
      }
      
      /* Set the Capture Compare Register value */
      tmpcnt = (uint32_t)((tmpfreq * PWM_InitStruct->PWM_DutyCycle) / 100);
      TIMERx->CH1CV = (uint32_t)tmpcnt;
      
      /* Write to TIMERx CHCTLR1 */
      TIMERx->CHCTLR1 = tmpccmrx;
      
      /* Set the Capture Compare Register Preload Bit */
      TIMERx->CHCTLR1 |= (uint16_t)TIMER_CHCTLR1_OC2PE;
      
      /* Write to TIMERx CHCTL2 */
      TIMERx->CHCTL2 = tmpccer;
      
      /* Write to TIMERx CCHP */
      TIMERx->CCHP &= (uint16_t)(~((uint16_t)TIMER_CCHP_OAEN));
      TIMERx->CCHP |= ((uint16_t)PWM_InitStruct->PWM_OCIdleState | (uint16_t)PWM_InitStruct->PWM_OCNIdleState);
      break;
      
    case PWM_CHANNEL_2:
      /* Get the TIMERx CHCTLR2 register value */
      tmpccmrx = TIMERx->CHCTLR2;
      /* Reset the Output Compare Mode Bits */
      tmpccmrx &= (uint16_t)(~((uint16_t)TIMER_CHCTLR2_OC3M));
      tmpccmrx &= (uint16_t)(~((uint16_t)TIMER_CHCTLR2_CC3S));
      
      /* Select the Output Compare Mode */
      tmpccmrx |= PWM_InitStruct->PWM_OCMode;
      
      /* Reset the Output Polarity level */
      tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH2P));
      /* Set the Output Compare Polarity */
      tmpccer |= (uint16_t)(PWM_InitStruct->PWM_OCPolarity << 8);
      
      /* Set the Output State */
      if(PWM_InitStruct->PWM_OutputState == ENABLE)
      {
        tmpccer |= (uint16_t)TIMER_CHCTL2_CH2EN;
      }
      else
      {
        tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH2EN));
      }
      
      /* Set the Output N State */
      if(PWM_InitStruct->PWM_OutputNState == ENABLE)
      {
        tmpccer |= (uint16_t)TIMER_CHCTL2_CH2NEN;
      }
      else
      {
        tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH2NEN));
      }
      
      /* Set the Capture Compare Register value */
      tmpcnt = (uint32_t)((tmpfreq * PWM_InitStruct->PWM_DutyCycle) / 100);
      TIMERx->CH2CV = (uint32_t)tmpcnt;
      
      /* Write to TIMERx CHCTLR2 */
      TIMERx->CHCTLR2 = tmpccmrx;
      
      /* Set the Capture Compare Register Preload Bit */
      TIMERx->CHCTLR2 |= (uint16_t)TIMER_CHCTLR2_OC3PE;
      
      /* Write to TIMERx CHCTL2 */
      TIMERx->CHCTL2 = tmpccer;
      
      /* Write to TIMERx CCHP */
      TIMERx->CCHP &= (uint16_t)(~((uint16_t)TIMER_CCHP_OAEN));
      TIMERx->CCHP |= ((uint16_t)PWM_InitStruct->PWM_OCIdleState | (uint16_t)PWM_InitStruct->PWM_OCNIdleState);
      break;
      
    case PWM_CHANNEL_3:
      /* Get the TIMERx CHCTLR2 register value */
      tmpccmrx = TIMERx->CHCTLR2;
      /* Reset the Output Compare Mode Bits */
      tmpccmrx &= (uint16_t)(~((uint16_t)TIMER_CHCTLR2_OC4M));
      tmpccmrx &= (uint16_t)(~((uint16_t)TIMER_CHCTLR2_CC4S));
      
      /* Select the Output Compare Mode */
      tmpccmrx |= (uint16_t)(PWM_InitStruct->PWM_OCMode << 8);
      
      /* Reset the Output Polarity level */
      tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH3P));
      /* Set the Output Compare Polarity */
      tmpccer |= (uint16_t)(PWM_InitStruct->PWM_OCPolarity << 12);
      
      /* Set the Output State */
      if(PWM_InitStruct->PWM_OutputState == ENABLE)
      {
        tmpccer |= (uint16_t)TIMER_CHCTL2_CH3EN;
      }
      else
      {
        tmpccer &= (uint16_t)(~((uint16_t)TIMER_CHCTL2_CH3EN));
      }
      
      /* Set the Capture Compare Register value */
      tmpcnt = (uint32_t)((tmpfreq * PWM_InitStruct->PWM_DutyCycle) / 100);
      TIMERx->CH3CV = (uint32_t)tmpcnt;
      
      /* Write to TIMERx CHCTLR2 */
      TIMERx->CHCTLR2 = tmpccmrx;
      
      /* Set the Capture Compare Register Preload Bit */
      TIMERx->CHCTLR2 |= (uint16_t)TIMER_CHCTLR2_OC4PE;
      
      /* Write to TIMERx CHCTL2 */
      TIMERx->CHCTL2 = tmpccer;
      break;
      
    default:
      break;
  }
  
  /* Set the Main Output Enable bit */
  if((TIMERx == TIMER0) || (TIMERx == TIMER1) || (TIMERx == TIMER2))
  {
    TIMERx->CCHP |= CCHP_OAEN_SET;
  }
}

/**
  * @brief  Fills each PWM_InitStruct member with its default value.
  * @param  PWM_InitStruct : pointer to a PWM_InitTypeDef structure which will be initialized.
  * @retval None
  */
void PWM_StructInit(PWM_InitTypeDef* PWM_InitStruct)
{
  /* Set the default configuration */
  PWM_InitStruct->PWM_Channel = PWM_CHANNEL_0;
  PWM_InitStruct->PWM_Frequency = 1000;  /* 1KHz */
  PWM_InitStruct->PWM_DutyCycle = 50;     /* 50% */
  PWM_InitStruct->PWM_CounterMode = PWM_COUNTERMODE_UP;
  PWM_InitStruct->PWM_OCMode = PWM_OCMODE_PWM1;
  PWM_InitStruct->PWM_OCPolarity = PWM_OCPOLARITY_HIGH;
  PWM_InitStruct->PWM_OutputState = ENABLE;
  PWM_InitStruct->PWM_OutputNState = DISABLE;
  PWM_InitStruct->PWM_Pulse = 0x0000;
  PWM_InitStruct->PWM_OCNIdleState = PWM_OCNIDLESTATE_RESET;
  PWM_InitStruct->PWM_OCIdleState = PWM_OCIDLESTATE_RESET;
}

/**
  * @brief  Enables or disables the specified TIMER peripheral.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  NewState: new state of the TIMERx peripheral.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWM_Cmd(TIMER_TypeDef* TIMERx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIMER Counter */
    TIMERx->CTL0 |= CTL0_CEN_SET;
  }
  else
  {
    /* Disable the TIMER Counter */
    TIMERx->CTL0 &= CTL0_CEN_RESET;
  }
}

/**
  * @brief  Enables or disables the TIMER peripheral Main Outputs.
  * @param  TIMERx: where x can be 0, 1, 2 to select the TIMER peripheral.
  * @param  NewState: new state of the TIMER peripheral Main Outputs.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWM_CtrlPWMOutput(TIMER_TypeDef* TIMERx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIMER Main Output */
    TIMERx->CCHP |= CCHP_OAEN_SET;
  }
  else
  {
    /* Disable the TIMER Main Output */
    TIMERx->CCHP &= CCHP_OAEN_RESET;
  }
}

/**
  * @brief  Configures the TIMERx Output Compare 1 Fast feature.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCFast: new state of the Output Compare Fast Enable Bit.
  *   This parameter can be one of the following values:
  *     @arg PWM_OCFast_Enable: TIM Output Compare Fast enable
  *     @arg PWM_OCFast_Disable: TIM Output Compare Fast disable
  * @retval None
  */
void PWM_OC1FastConfig(TIMER_TypeDef* TIMERx, uint16_t PWM_OCFast)
{
  uint16_t tmpccmr1 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCFAST_STATE(PWM_OCFast));
  
  tmpccmr1 = TIMERx->CHCTLR1;
  
  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIMER_CHCTLR1_OC1FE);
  
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= PWM_OCFast;
  
  /* Write to TIMERx CHCTLR1 */
  TIMERx->CHCTLR1 = tmpccmr1;
}

/**
  * @brief  Configures the TIMERx Output Compare 2 Fast feature.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCFast: new state of the Output Compare Fast Enable Bit.
  *   This parameter can be one of the following values:
  *     @arg PWM_OCFast_Enable: TIM Output Compare Fast enable
  *     @arg PWM_OCFast_Disable: TIM Output Compare Fast disable
  * @retval None
  */
void PWM_OC2FastConfig(TIMER_TypeDef* TIMERx, uint16_t PWM_OCFast)
{
  uint16_t tmpccmr1 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCFAST_STATE(PWM_OCFast));
  
  tmpccmr1 = TIMERx->CHCTLR1;
  
  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIMER_CHCTLR1_OC2FE);
  
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= (uint16_t)(PWM_OCFast << 8);
  
  /* Write to TIMERx CHCTLR1 */
  TIMERx->CHCTLR1 = tmpccmr1;
}

/**
  * @brief  Configures the TIMERx Output Compare 3 Fast feature.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCFast: new state of the Output Compare Fast Enable Bit.
  *   This parameter can be one of the following values:
  *     @arg PWM_OCFast_Enable: TIM Output Compare Fast enable
  *     @arg PWM_OCFast_Disable: TIM Output Compare Fast disable
  * @retval None
  */
void PWM_OC3FastConfig(TIMER_TypeDef* TIMERx, uint16_t PWM_OCFast)
{
  uint16_t tmpccmr2 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCFAST_STATE(PWM_OCFast));
  
  tmpccmr2 = TIMERx->CHCTLR2;
  
  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIMER_CHCTLR2_OC3FE);
  
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= PWM_OCFast;
  
  /* Write to TIMERx CHCTLR2 */
  TIMERx->CHCTLR2 = tmpccmr2;
}

/**
  * @brief  Configures the TIMERx Output Compare 4 Fast feature.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCFast: new state of the Output Compare Fast Enable Bit.
  *   This parameter can be one of the following values:
  *     @arg PWM_OCFast_Enable: TIM Output Compare Fast enable
  *     @arg PWM_OCFast_Disable: TIM Output Compare Fast disable
  * @retval None
  */
void PWM_OC4FastConfig(TIMER_TypeDef* TIMERx, uint16_t PWM_OCFast)
{
  uint16_t tmpccmr2 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCFAST_STATE(PWM_OCFast));
  
  tmpccmr2 = TIMERx->CHCTLR2;
  
  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIMER_CHCTLR2_OC4FE);
  
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= (uint16_t)(PWM_OCFast << 8);
  
  /* Write to TIMERx CHCTLR2 */
  TIMERx->CHCTLR2 = tmpccmr2;
}

/**
  * @brief  Sets the TIMERx Capture Compare1 Register value
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  Compare1: specifies the Capture Compare1 register new value.
  * @retval None
  */
void PWM_SetCompare1(TIMER_TypeDef* TIMERx, uint32_t Compare1)
{
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  
  /* Set the Capture Compare1 Register value */
  TIMERx->CH0CV = Compare1;
}

/**
  * @brief  Sets the TIMERx Capture Compare2 Register value
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  Compare2: specifies the Capture Compare2 register new value.
  * @retval None
  */
void PWM_SetCompare2(TIMER_TypeDef* TIMERx, uint32_t Compare2)
{
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  
  /* Set the Capture Compare2 Register value */
  TIMERx->CH1CV = Compare2;
}

/**
  * @brief  Sets the TIMERx Capture Compare3 Register value
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  Compare3: specifies the Capture Compare3 register new value.
  * @retval None
  */
void PWM_SetCompare3(TIMER_TypeDef* TIMERx, uint32_t Compare3)
{
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  
  /* Set the Capture Compare3 Register value */
  TIMERx->CH2CV = Compare3;
}

/**
  * @brief  Sets the TIMERx Capture Compare4 Register value
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  Compare4: specifies the Capture Compare4 register new value.
  * @retval None
  */
void PWM_SetCompare4(TIMER_TypeDef* TIMERx, uint32_t Compare4)
{
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  
  /* Set the Capture Compare4 Register value */
  TIMERx->CH3CV = Compare4;
}

/**
  * @brief  Sets the TIMERx Auto Reload Register value
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  Autoreload: specifies the Auto Reload register new value.
  * @retval None
  */
void PWM_SetAutoreload(TIMER_TypeDef* TIMERx, uint32_t Autoreload)
{
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  
  /* Set the Autoreload Register value */
  TIMERx->CAR = Autoreload;
}

/**
  * @brief  Sets the TIMERx Prescaler Register value
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  Prescaler: specifies the Prescaler register new value.
  * @retval None
  */
void PWM_SetPrescaler(TIMER_TypeDef* TIMERx, uint16_t Prescaler)
{
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  
  /* Set the Prescaler value */
  TIMERx->PSC = Prescaler;
}

/**
  * @brief  Forces the TIMERx output 1 waveform to active or inactive level.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_ForcedAction: specifies the forced Action to be set to the output waveform.
  *   This parameter can be one of the following values:
  *     @arg PWM_ForcedAction_Active: Force active level on OC1REF
  *     @arg PWM_ForcedAction_InActive: Force inactive level on OC1REF.
  * @retval None
  */
void PWM_ForcedOC1Config(TIMER_TypeDef* TIMERx, uint16_t PWM_ForcedAction)
{
  uint16_t tmpccmr1 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_FORCED_ACTION(PWM_ForcedAction));
  
  tmpccmr1 = TIMERx->CHCTLR1;
  
  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIMER_CHCTLR1_OC1M);
  
  /* Configure The Forced output Mode */
  tmpccmr1 |= PWM_ForcedAction;
  
  /* Write to TIMERx CHCTLR1 register */
  TIMERx->CHCTLR1 = tmpccmr1;
}

/**
  * @brief  Forces the TIMERx output 2 waveform to active or inactive level.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_ForcedAction: specifies the forced Action to be set to the output waveform.
  *   This parameter can be one of the following values:
  *     @arg PWM_ForcedAction_Active: Force active level on OC2REF
  *     @arg PWM_ForcedAction_InActive: Force inactive level on OC2REF.
  * @retval None
  */
void PWM_ForcedOC2Config(TIMER_TypeDef* TIMERx, uint16_t PWM_ForcedAction)
{
  uint16_t tmpccmr1 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_FORCED_ACTION(PWM_ForcedAction));
  
  tmpccmr1 = TIMERx->CHCTLR1;
  
  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIMER_CHCTLR1_OC2M);
  
  /* Configure The Forced output Mode */
  tmpccmr1 |= (uint16_t)(PWM_ForcedAction << 8);
  
  /* Write to TIMERx CHCTLR1 register */
  TIMERx->CHCTLR1 = tmpccmr1;
}

/**
  * @brief  Forces the TIMERx output 3 waveform to active or inactive level.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_ForcedAction: specifies the forced Action to be set to the output waveform.
  *   This parameter can be one of the following values:
  *     @arg PWM_ForcedAction_Active: Force active level on OC3REF
  *     @arg PWM_ForcedAction_InActive: Force inactive level on OC3REF.
  * @retval None
  */
void PWM_ForcedOC3Config(TIMER_TypeDef* TIMERx, uint16_t PWM_ForcedAction)
{
  uint16_t tmpccmr2 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_FORCED_ACTION(PWM_ForcedAction));
  
  tmpccmr2 = TIMERx->CHCTLR2;
  
  /* Reset the OC3M Bits */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIMER_CHCTLR2_OC3M);
  
  /* Configure The Forced output Mode */
  tmpccmr2 |= PWM_ForcedAction;
  
  /* Write to TIMERx CHCTLR2 register */
  TIMERx->CHCTLR2 = tmpccmr2;
}

/**
  * @brief  Forces the TIMERx output 4 waveform to active or inactive level.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_ForcedAction: specifies the forced Action to be set to the output waveform.
  *   This parameter can be one of the following values:
  *     @arg PWM_ForcedAction_Active: Force active level on OC4REF
  *     @arg PWM_ForcedAction_InActive: Force inactive level on OC4REF.
  * @retval None
  */
void PWM_ForcedOC4Config(TIMER_TypeDef* TIMERx, uint16_t PWM_ForcedAction)
{
  uint16_t tmpccmr2 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_FORCED_ACTION(PWM_ForcedAction));
  
  tmpccmr2 = TIMERx->CHCTLR2;
  
  /* Reset the OC4M Bits */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIMER_CHCTLR2_OC4M);
  
  /* Configure The Forced output Mode */
  tmpccmr2 |= (uint16_t)(PWM_ForcedAction << 8);
  
  /* Write to TIMERx CHCTLR2 register */
  TIMERx->CHCTLR2 = tmpccmr2;
}

/**
  * @brief  Enables or disables the TIMERx peripheral Preload register on CCR1.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCPreload: new state of the TIMERx peripheral Preload register
  *   This parameter can be one of the following values:
  *     @arg PWM_OCPreload_Enable
  *     @arg PWM_OCPreload_Disable
  * @retval None
  */
void PWM_OC1PreloadConfig(TIMER_TypeDef* TIMERx, uint16_t PWM_OCPreload)
{
  uint16_t tmpccmr1 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCPRELOAD_STATE(PWM_OCPreload));
  
  tmpccmr1 = TIMERx->CHCTLR1;
  
  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIMER_CHCTLR1_OC1PE);
  
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= PWM_OCPreload;
  
  /* Write to TIMERx CHCTLR1 register */
  TIMERx->CHCTLR1 = tmpccmr1;
}

/**
  * @brief  Enables or disables the TIMERx peripheral Preload register on CCR2.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCPreload: new state of the TIMERx peripheral Preload register
  *   This parameter can be one of the following values:
  *     @arg PWM_OCPreload_Enable
  *     @arg PWM_OCPreload_Disable
  * @retval None
  */
void PWM_OC2PreloadConfig(TIMER_TypeDef* TIMERx, uint16_t PWM_OCPreload)
{
  uint16_t tmpccmr1 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCPRELOAD_STATE(PWM_OCPreload));
  
  tmpccmr1 = TIMERx->CHCTLR1;
  
  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIMER_CHCTLR1_OC2PE);
  
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(PWM_OCPreload << 8);
  
  /* Write to TIMERx CHCTLR1 register */
  TIMERx->CHCTLR1 = tmpccmr1;
}

/**
  * @brief  Enables or disables the TIMERx peripheral Preload register on CCR3.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCPreload: new state of the TIMERx peripheral Preload register
  *   This parameter can be one of the following values:
  *     @arg PWM_OCPreload_Enable
  *     @arg PWM_OCPreload_Disable
  * @retval None
  */
void PWM_OC3PreloadConfig(TIMER_TypeDef* TIMERx, uint16_t PWM_OCPreload)
{
  uint16_t tmpccmr2 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCPRELOAD_STATE(PWM_OCPreload));
  
  tmpccmr2 = TIMERx->CHCTLR2;
  
  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIMER_CHCTLR2_OC3PE);
  
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= PWM_OCPreload;
  
  /* Write to TIMERx CHCTLR2 register */
  TIMERx->CHCTLR2 = tmpccmr2;
}

/**
  * @brief  Enables or disables the TIMERx peripheral Preload register on CCR4.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCPreload: new state of the TIMERx peripheral Preload register
  *   This parameter can be one of the following values:
  *     @arg PWM_OCPreload_Enable
  *     @arg PWM_OCPreload_Disable
  * @retval None
  */
void PWM_OC4PreloadConfig(TIMER_TypeDef* TIMERx, uint16_t PWM_OCPreload)
{
  uint16_t tmpccmr2 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCPRELOAD_STATE(PWM_OCPreload));
  
  tmpccmr2 = TIMERx->CHCTLR2;
  
  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIMER_CHCTLR2_OC4PE);
  
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= (uint16_t)(PWM_OCPreload << 8);
  
  /* Write to TIMERx CHCTLR2 register */
  TIMERx->CHCTLR2 = tmpccmr2;
}

/**
  * @brief  Configures the TIMERx Output Compare 1 Clear Bit.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCClear: new state of the Output Compare Clear Enable Bit.
  *   This parameter can be one of the following values:
  *     @arg PWM_OCClear_Enable: TIM Output clear enable
  *     @arg PWM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void PWM_ClearOC1Ref(TIMER_TypeDef* TIMERx, uint16_t PWM_OCClear)
{
  uint16_t tmpccmr1 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCCLEAR_STATE(PWM_OCClear));
  
  tmpccmr1 = TIMERx->CHCTLR1;
  
  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIMER_CHCTLR1_OC1CE);
  
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= PWM_OCClear;
  
  /* Write to TIMERx CHCTLR1 register */
  TIMERx->CHCTLR1 = tmpccmr1;
}

/**
  * @brief  Configures the TIMERx Output Compare 2 Clear Bit.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCClear: new state of the Output Compare Clear Enable Bit.
  *   This parameter can be one of the following values:
  *     @arg PWM_OCClear_Enable: TIM Output clear enable
  *     @arg PWM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void PWM_ClearOC2Ref(TIMER_TypeDef* TIMERx, uint16_t PWM_OCClear)
{
  uint16_t tmpccmr1 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCCLEAR_STATE(PWM_OCClear));
  
  tmpccmr1 = TIMERx->CHCTLR1;
  
  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIMER_CHCTLR1_OC2CE);
  
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(PWM_OCClear << 8);
  
  /* Write to TIMERx CHCTLR1 register */
  TIMERx->CHCTLR1 = tmpccmr1;
}

/**
  * @brief  Configures the TIMERx Output Compare 3 Clear Bit.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCClear: new state of the Output Compare Clear Enable Bit.
  *   This parameter can be one of the following values:
  *     @arg PWM_OCClear_Enable: TIM Output clear enable
  *     @arg PWM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void PWM_ClearOC3Ref(TIMER_TypeDef* TIMERx, uint16_t PWM_OCClear)
{
  uint16_t tmpccmr2 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCCLEAR_STATE(PWM_OCClear));
  
  tmpccmr2 = TIMERx->CHCTLR2;
  
  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIMER_CHCTLR2_OC3CE);
  
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= PWM_OCClear;
  
  /* Write to TIMERx CHCTLR2 register */
  TIMERx->CHCTLR2 = tmpccmr2;
}

/**
  * @brief  Configures the TIMERx Output Compare 4 Clear Bit.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_OCClear: new state of the Output Compare Clear Enable Bit.
  *   This parameter can be one of the following values:
  *     @arg PWM_OCClear_Enable: TIM Output clear enable
  *     @arg PWM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void PWM_ClearOC4Ref(TIMER_TypeDef* TIMERx, uint16_t PWM_OCClear)
{
  uint16_t tmpccmr2 = 0;
  
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_OCCLEAR_STATE(PWM_OCClear));
  
  tmpccmr2 = TIMERx->CHCTLR2;
  
  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIMER_CHCTLR2_OC4CE);
  
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(PWM_OCClear << 8);
  
  /* Write to TIMERx CHCTLR2 register */
  TIMERx->CHCTLR2 = tmpccmr2;
}

/**
  * @brief  Selects the TIMERx peripheral Capture Compare DMA source.
  * @param  TIMERx: where x can be 0, 1, 2, 3 or 4 to select the TIMER peripheral.
  * @param  PWM_CCADMA: specifies the Capture Compare DMA source.
  *   This parameter can be one of the following values:
  *     @arg PWM_CCADMA_Enable: CCx DMA request sent when capture or compare match occurs
  *     @arg PWM_CCADMA_Disable: CCx DMA requests are disabled
  * @retval None
  */
void PWM_CCADMACmd(TIMER_TypeDef* TIMERx, uint16_t PWM_CCADMA)
{
  /* Check the parameters */
  assert_param(IS_PWM_ALL_PERIPH(TIMERx));
  assert_param(IS_PWM_CCADMA_STATE(PWM_CCADMA));
  
  if(PWM_CCADMA == PWM_CCADMA_Enable)
  {
    /* Set the CCDS Bit */
    TIMERx->CTL0 |= TIMER_CCADMA_Enable;
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMERx->CTL0 &= (uint16_t)~((uint16_t)TIMER_CCADMA_Enable);
  }
}

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/******************* (C) COPYRIGHT 2025 GIGADEVICE *****END OF FILE****/