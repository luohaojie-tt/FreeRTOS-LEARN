/**
  ******************************************************************************
  * @file    adc_example.c
  * @author  Auto-generated by Claude Code
  * @version V1.0.0
  * @date    24-August-2025
  * @brief   ADC driver usage example
  ******************************************************************************
  * @attention
  *
  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  *
  * COPYRIGHT 2025 GIGADEVICE
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "gd32f10x_adc.h"
#include "gd32f10x_gpio.h"
#include "gd32f10x_rcc.h"
#include "FreeRTOS.h"
#include "task.h"
#include <stdio.h>

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
#define ADC_TASK_PRIORITY       ( tskIDLE_PRIORITY + 2 )
#define ADC_TASK_STACK_SIZE     ( configMINIMAL_STACK_SIZE * 2 )

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
ADC_InitTypeDef ADC_InitStructure;
uint16_t adc_value = 0;

/* Private function prototypes -----------------------------------------------*/
void ADC_GPIO_Config(void);
void ADC_Config(void);
void ADC_Task(void *pvParameters);

/* Private functions ---------------------------------------------------------*/

/**
  * @brief  Configure the ADC GPIO ports.
  * @param  None
  * @retval None
  */
void ADC_GPIO_Config(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    /* Enable GPIOA clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

    /* Configure PA0 (ADC Channel 0) as analog input */
    GPIO_InitStructure.GPIO_Pin = GPIO_PIN_0;
    GPIO_InitStructure.GPIO_Mode = GPIO_MODE_AIN;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
}

/**
  * @brief  Configure the ADC interface.
  * @param  None
  * @retval None
  */
void ADC_Config(void)
{
    /* Enable ADC0 clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC0, ENABLE);
    
    /* ADC0 configuration */
    ADC_InitStructure.ADC_Mode = ADC_MODE_INDEPENDENT;
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;
    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_EXTERNALTRIGCONV_SOFTWARE;
    ADC_InitStructure.ADC_DataAlign = ADC_DATAALIGN_RIGHT;
    ADC_InitStructure.ADC_NbrOfChannel = 1;
    ADC_Init(ADC0, &ADC_InitStructure);
    
    /* ADC0 regular channel configuration */
    ADC_RegularChannelConfig(ADC0, ADC_CHANNEL_0, 1, ADC_SAMPLETIME_239POINT5);
    
    /* Enable ADC0 */
    ADC_Cmd(ADC0, ENABLE);
    
    /* Enable ADC0 reset calibration register */
    ADC_ResetCalibration(ADC0);
    
    /* Check the end of ADC0 reset calibration register */
    while(ADC_GetResetCalibrationStatus(ADC0));
    
    /* Start ADC0 calibration */
    ADC_StartCalibration(ADC0);
    
    /* Check the end of ADC0 calibration */
    while(ADC_GetCalibrationStatus(ADC0));
}

/**
  * @brief  ADC Task.
  * @param  pvParameters: pointer that will be passed to the task
  * @retval None
  */
void ADC_Task(void *pvParameters)
{
    while(1)
    {
        /* Start ADC0 Software Conversion */
        ADC_SoftwareStartConvCmd(ADC0, ENABLE);
        
        /* Wait until conversion completion */
        while(!ADC_GetFlagStatus(ADC0, ADC_FLAG_EOC));
        
        /* Get the conversion value */
        adc_value = ADC_GetConversionValue(ADC0);
        
        /* Clear EOC flag */
        ADC_ClearFlag(ADC0, ADC_FLAG_EOC);
        
        /* Print ADC value (in a real application, you might send this over UART or display it) */
        printf("ADC Value: %d\r\n", adc_value);
        
        /* Delay for 1 second */
        vTaskDelay(1000 / portTICK_RATE_MS);
    }
}

/**
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
    /* Configure ADC GPIO ports */
    ADC_GPIO_Config();
    
    /* Configure ADC interface */
    ADC_Config();
    
    /* Create ADC task */
    xTaskCreate(ADC_Task, "ADC_Task", ADC_TASK_STACK_SIZE, NULL, ADC_TASK_PRIORITY, NULL);
    
    /* Start the scheduler */
    vTaskStartScheduler();
    
    /* Should never reach here */
    while(1);
}